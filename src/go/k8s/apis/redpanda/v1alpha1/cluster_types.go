// Copyright 2021 Vectorized, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0

package v1alpha1

import (
	"fmt"

	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
	// Important: Run "make" to regenerate code after modifying this file

	// Image is the fully qualified name of the Redpanda container
	Image string `json:"image,omitempty"`
	// Version is the Redpanda container tag
	Version string `json:"version,omitempty"`
	// Replicas determine how big the cluster will be.
	// +kubebuilder:validation:Minimum=0
	Replicas *int32 `json:"replicas,omitempty"`
	// Resources used by each Redpanda container
	// To calculate overall resource consumption one need to
	// multiply replicas against limits
	Resources corev1.ResourceRequirements `json:"resources"`
	// Configuration represent redpanda specific configuration
	Configuration RedpandaConfig `json:"configuration,omitempty"`

	// ExternalConnectivity adds listener that can be reached outside
	// of a kubernetes cluster. The Service type NodePort will be used
	// to create unique ports on each Kubernetes nodes. Those nodes
	// need to be reachable from the client perspective. Setting up
	// any additional resources in cloud or premise is the responsibility
	// of the Redpanda operator user e.g. allow to reach the nodes by
	// creating new rule in AWS security group.
	// Inside the container the Configuration.KafkaAPI.Port + 1 will be
	// used as a external listener. This port is tight to the autogenerated
	// host port. The collision between Kafka external, Kafka internal,
	// Admin and RPC port is checked in the webhook.
	ExternalConnectivity bool `json:"externalConnectivity,omitempty"`
}

// ClusterStatus defines the observed state of Cluster
type ClusterStatus struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
	// Important: Run "make" to regenerate code after modifying this file

	// Replicas show how many nodes are working in the cluster
	// +optional
	Replicas int32 `json:"replicas"`
	// Nodes of the provisioned redpanda nodes
	// +optional
	Nodes NodesList `json:"nodes,omitempty"`
	// Indicates cluster is upgrading
	// +optional
	Upgrading bool `json:"upgrading"`
}

// NodesList shows where client can find Redpanda brokers
type NodesList struct {
	Internal []string `json:"internal,omitempty"`
	External []string `json:"external,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status

// Cluster is the Schema for the clusters API
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ClusterSpec   `json:"spec,omitempty"`
	Status ClusterStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// ClusterList contains a list of Cluster
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// RedpandaConfig is the definition of the main configuration
type RedpandaConfig struct {
	RPCServer     SocketAddress `json:"rpcServer,omitempty"`
	KafkaAPI      SocketAddress `json:"kafkaApi,omitempty"`
	AdminAPI      SocketAddress `json:"admin,omitempty"`
	DeveloperMode bool          `json:"developerMode,omitempty"`
	TLS           TLSConfig     `json:"tls,omitempty"`
}

// TLSConfig configures TLS for redpanda
//
// If KafkaAPIEnabled is set to true, one-way TLS verification is enabled.
// In that case, a key pair ('tls.crt', 'tls.key') and CA certificate 'ca.crt'
// are generated and stored in a Secret with the same name and namespace as the
// Redpanda cluster. 'ca.crt', must be used by a client as a trustore when
// communicating with Redpanda.
//
// If RequireClientAuth is set to true, two-way TLS verification is enabled.
// In that case, a node and two client certificates are created. The node
// certificate is used by redpanda nodes. One client certificate is used by the
// operator client to make KafkaAPI calls. The other client certificate is
// available for Redpanda users to call KafkaAPI. The client certificate can be
// retrieved from the Secret named '<redpanda-cluster-name>-user-client'.
// The secret is stored in the same namespace as Redpanda cluster.
type TLSConfig struct {
	KafkaAPIEnabled bool `json:"kafkaApiEnabled,omitempty"`
	// References cert-manager Issuer or ClusterIssuer. When provided, this
	// issuer will be used to issue node as well as client certificates.
	// Typically you want to provide the issuer when a generated self-signed one
	// is not enough and you need to have a verifiable chain with a proper CA
	// certificate.
	IssuerRef *cmmeta.ObjectReference `json:"issuerRef,omitempty"`
	// Enables two-way verification on the server side. If enabled, all Kafka
	// API clients are required to have a valid client certificate.
	RequireClientAuth bool `json:"requireClientAuth,omitempty"`
}

// SocketAddress provide the way to configure the port
type SocketAddress struct {
	Port int `json:"port,omitempty"`
}

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}

// FullImageName returns image name including version
func (r *Cluster) FullImageName() string {
	return fmt.Sprintf("%s:%s", r.Spec.Image, r.Spec.Version)
}
